# Common code for generating u-boot FIT binary images for u-boot.
# Also generate an image for the OpenBMC ROM and upgradable flash.
#
# Modified for Xilinx ZynQ to generate a QSPI image
#             SPL + uboot
#
# and
#
# a FIT Image with Kernel, Device Tree, RamDisk and FPGA Image
#
# Copyright (C) 2016-Present, Facebook, Inc.
# Copyright (C) 2018-Present, Iceotope Ltd.

def image_types_module(d):
    distro = d.getVar('DISTRO_CODENAME', True)
    if distro == 'fido' or distro == 'krogoth':
        return 'image_types_uboot'
    return 'image_types'

# Inherit u-boot classes if legacy uboot images are in use.
IMAGE_TYPE_MODULE = '${@image_types_module(d)}'
inherit ${IMAGE_TYPE_MODULE}
inherit kernel-fitimage

# Make Rocko images work just like they would in krogoth
# That means, let conversion on u-boot call into oe_mkimage so
# we may do our fit conversions.
# TODO:
# More up-stream-worthy method is to use the chaining of conversions.
CONVERSION_CMD_u-boot = "oe_mkimage ${IMAGE_NAME}.rootfs.${type} none"

# Changing the image compression from gz to lzma achieves 30% saving (~3M).
# However, the current u-boot does not have lzma enabled. Stick to gz
# until we generate a new u-boot image.
#IMAGE_FSTYPES += "cpio.lzma.u-boot"
UBOOT_IMAGE_LOADADDRESS ?= "0x00080000"
UBOOT_IMAGE_ENTRYPOINT ?= "0x00080000"
UBOOT_RAMDISK_LOADADDRESS ?= "0x00800000"

# U-Boot is placed at an absolute position relative to the start of the first
# U-Boot FIT. This value, like most others, depends on U-Boot machine
# configurations.
ROM_UBOOT_POSITION ?= "0x4000"
ROM_UBOOT_LOADADDRESS ?= "0x28084000"

# Set sizes and offsets in KB:
#   For kernel and rootfs: 16384
#   For kernel only: 2690
FLASH_SIZE ?= "1024"

UBOOT_SOURCE ?= "${DEPLOY_DIR_IMAGE}/u-boot-${MACHINE}.${UBOOT_SUFFIX}"
FIT_SOURCE = "${DEPLOY_DIR_IMAGE}/fit-${MACHINE}.its"

FIT[vardepsexclude] = "DATETIME"
FIT ?= "fit-${MACHINE}-${DATETIME}.itb"
FIT_LINK ?= "fit-${MACHINE}.itb"

FLASH_IMAGE[vardepsexclude] += "DATETIME"
FLASH_IMAGE ?= "flash-${MACHINE}-${DATETIME}"
FLASH_IMAGE_LINK ?= "flash-${MACHINE}"

# ROM-based boot variables
UBOOT_RECOVERY_SOURCE ?= "${DEPLOY_DIR_IMAGE}/u-boot-recovery-${MACHINE}.${UBOOT_SUFFIX}"
UBOOT_SPL_SOURCE ?= "${DEPLOY_DIR_IMAGE}/${SPL_BINARYNAME}-${MACHINE}"
UBOOT_FIT_SOURCE ?= "${STAGING_DIR_HOST}/etc/u-boot-fit-${MACHINE}.its"

UBOOT_FIT[vardepsexclude] = "DATETIME"
UBOOT_FIT ?= "u-boot-fit-${MACHINE}-${DATETIME}.itb"
UBOOT_FIT_LINK ?= "u-boot-fit-${MACHINE}.itb"

IMAGE_PREPROCESS_COMMAND += " generate_data_mount_dir ; "
IMAGE_POSTPROCESS_COMMAND += " flash_image_generate ; "

VERIFIED_BOOT_HASH_ALGORITHM ?= "md5"

FPGA_DATA_FILENAME ?= "fpga.bin.bit"

generate_data_mount_dir() {
    mkdir -p "${IMAGE_ROOTFS}/mnt/data"
}

flash_image_generate() {
    FIT_DESTINATION="${DEPLOY_DIR_IMAGE}/${FIT}"
    FLASH_IMAGE_DESTINATION="${DEPLOY_DIR_IMAGE}/${FLASH_IMAGE}"
    UBOOT_FIT_DESTINATION="${DEPLOY_DIR_IMAGE}/${UBOOT_FIT}"

    if [ ! -f $UBOOT_SOURCE ]; then
        echo "U-boot file ${UBOOT_SOURCE} does not exist"
        return 1
    fi

    if [ ! -f $UBOOT_SPL_SOURCE ]; then
        echo "U-boot SPL file ${UBOOT_SPL_SOURCE} does not exist"
        return 1
    fi

    rm -rf $FLASH_IMAGE_DESTINATION

    # Bunch of zeros
    dd if=/dev/zero of=${FLASH_IMAGE_DESTINATION} bs=1k count=${FLASH_SIZE}

    # Put the SPL at the start, the image is a "Zynq" boot image file, generated by
    # uboot-package
    dd if=${UBOOT_SPL_SOURCE} of=${FLASH_IMAGE_DESTINATION} conv=notrunc

    ## Add the u-boot itself to the end of the file, at 0x100000
    cat ${UBOOT_SOURCE} >>${FLASH_IMAGE_DESTINATION}

    ## This is the QSPI Boot Image
    ln -sf ${FLASH_IMAGE} ${DEPLOY_DIR_IMAGE}/${FLASH_IMAGE_LINK}

    ## This is the OS Image
    ln -sf ${FIT} ${DEPLOY_DIR_IMAGE}/${FIT_LINK}
}

oe_mkimage() {
    echo "Generating FIT Image config ${FIT_SOURCE}"
    FIT_DESTINATION="${DEPLOY_DIR_IMAGE}/${FIT}"
    UBOOT_FIT_DESTINATION="${DEPLOY_DIR_IMAGE}/${UBOOT_FIT}"
    KERNEL_FILE="${DEPLOY_DIR_IMAGE}/${KERNEL_IMAGETYPE}"

    RAMDISK_FILE="${DEPLOY_DIR_IMAGE}/$1"
    # Newer oe-core (>Krogoth) copies the image after this step.
    # Hence we need to use the path from ${IMGDEPLOYDIR}.
    if [ ! -e ${RAMDISK_FILE} ]; then
      RAMDISK_FILE="${IMGDEPLOYDIR}/$1"
    fi

    rm -f ${FIT_SOURCE}

    fitimage_emit_fit_header ${FIT_SOURCE}

    # Step 1: Prepare a kernel image section
    fitimage_emit_section_maint ${FIT_SOURCE} imagestart
    fitimage_emit_section_kernel ${FIT_SOURCE} 1 "${KERNEL_FILE}" "none" \
        ${UBOOT_IMAGE_LOADADDRESS} ${UBOOT_IMAGE_ENTRYPOINT}

    # Step 2: Prepare a ramdisk image section
    fitimage_emit_section_ramdisk ${FIT_SOURCE} 1 ${RAMDISK_FILE} "gzip" \
        ${UBOOT_RAMDISK_LOADADDRESS}

    # Step 3: Prepare a Device Tree image section
    fitimage_emit_section_devicetree ${FIT_SOURCE} 1 \
      "${DEPLOY_DIR_IMAGE}/${DEVICE_TREE_BINARY_NAME}" "none"

    # Step 4: Prepare a FPGA image section
    fitimage_emit_section_fpga ${FIT_SOURCE} 1 \
      "${DEPLOY_DIR_IMAGE}/${FPGA_DATA_FILENAME}"

    fitimage_emit_section_maint ${FIT_SOURCE} sectend


    # Step 5: Prepare a configurations section
    fitimage_emit_section_maint ${FIT_SOURCE} confstart
    fitimage_emit_section_firmware_config ${FIT_SOURCE} 1 1 1 1
    fitimage_emit_section_maint ${FIT_SOURCE} sectend
    fitimage_emit_section_maint ${FIT_SOURCE} fitend

    # Create Image
    mkimage -f ${FIT_SOURCE} ${FIT_DESTINATION}

}

## Stuff that was in the secure boot recipe
# Emit the fitImage ITS header
# $1 - FIT source file
fitimage_emit_fit_header() {
    cat << EOF >> ${1}
/dts-v1/;

/ {
        description = "U-Boot fitImage for ${DISTRO_NAME}/${PV}/${MACHINE}";
        #address-cells = <1>;
EOF
}

# Emit the fitImage section bits
# $1 - FIT source file
# $2 - section type:
#   imagestart - image section start
#   confstart  - configuration section start
#   sectend    - section end
#   fitend     - fitimage end
fitimage_emit_section_maint() {
    SOURCE=$1
    case $2 in
    imagestart)
        cat << EOF >> ${SOURCE}

    images {
EOF
    ;;
    confstart)
        cat << EOF >> ${SOURCE}

    configurations {
EOF
    ;;
    sectend)
        cat << EOF >> ${SOURCE}
    };
EOF
    ;;
    fitend)
        cat << EOF >> ${SOURCE}
};
EOF
    ;;
    esac
}

#
# Emit the fitImage ITS firmware section
#
# $1 - FIT source
# $2 - Image counter
# $3 - Path to U-Boot image
# $4 - Load address
# $5 - Entry point
fitimage_emit_section_firmware() {
    SOURCE=$1
    IMAGE_COUNTER=$2
    IMAGE_FIRMWARE=$3
    LOAD_ADDRESS=$4
    ENTRY_POINT=$5

    cat << EOF >> ${SOURCE}
        firmware@${IMAGE_COUNTER} {
            description = "u-boot";
            data = /incbin/("${IMAGE_FIRMWARE}");
            type = "firmware";
            arch = "${UBOOT_ARCH}";
            os = "u-boot";
            compression = "none";
            hash@1 {
                algo = "${VERIFIED_BOOT_HASH_ALGORITHM}";
            };
        };
EOF
}

#
# Emit the fitImage ITS kernel section
#
# $1 - FIT source
# $2 - Image counter
# $3 - Path to kernel image
# $4 - Compression type
# $5 - Load address
# $6 - Entry point
fitimage_emit_section_kernel() {
    SOURCE=$1
    IMAGE_COUNTER=$2
    IMAGE_KERNEL=$3
    IMAGE_COMPRESSION=$4
    LOAD_ADDRESS=$5
    ENTRY_POINT=$6

    cat << EOF >> ${SOURCE}
        kernel@${IMAGE_COUNTER} {
            description = "Linux kernel";
            data = /incbin/("${IMAGE_KERNEL}");
            type = "kernel";
            arch = "${UBOOT_ARCH}";
            os = "linux";
            compression = "${IMAGE_COMPRESSION}";
            load = <${LOAD_ADDRESS}>;
            entry = <${ENTRY_POINT}>;
            hash@1 {
                algo = "${VERIFIED_BOOT_HASH_ALGORITHM}";
            };
        };
EOF
}

#
# Emit the fitImage ITS ramdisk section
#
# $1 - FIT source
# $2 - Image counter
# $3 - Path to ramdisk image
# $4 - Compression type
# $5 - Load address
fitimage_emit_section_ramdisk() {
    SOURCE=$1
    IMAGE_COUNTER=$2
    IMAGE_RAMDISK=$3
    IMAGE_COMPRESSION=$4
    LOAD_ADDRESS=$5

    cat << EOF >> ${SOURCE}
        ramdisk@${IMAGE_COUNTER} {
            description = "RAMDISK";
            data = /incbin/("${IMAGE_RAMDISK}");
            type = "ramdisk";
            arch = "${UBOOT_ARCH}";
            os = "linux";
            compression = "${IMAGE_COMPRESSION}";
/*            load = <${LOAD_ADDRESS}>; */
            hash@1 {
                algo = "${VERIFIED_BOOT_HASH_ALGORITHM}";
            };
        };
EOF
}

#
# Emit the fitImage ITS devicetree section
#
# $1 - FIT source
# $2 - Image counter
# $3 - Path to device tree image
# $4 - Compression type
fitimage_emit_section_devicetree() {
    SOURCE=$1
    IMAGE_COUNTER=$2
    IMAGE_DEVICETREE=$3
    IMAGE_COMPRESSION=$4

    cat << EOF >> ${SOURCE}
        fdt@${IMAGE_COUNTER} {
            description = "DEVICETREE";
            data = /incbin/("${IMAGE_DEVICETREE}");
            type = "flat_dt";
            arch = "${UBOOT_ARCH}";
            os = "linux";
            compression = "${IMAGE_COMPRESSION}";
            hash@1 {
                algo = "${VERIFIED_BOOT_HASH_ALGORITHM}";
            };
        };
EOF
}

#
# Emit the fitImage ITS fpga section
#
# $1 - FIT source
# $2 - Image counter
# $3 - Path to fpga image
fitimage_emit_section_fpga() {
    SOURCE=$1
    IMAGE_COUNTER=$2
    IMAGE_FPGA=$3

    cat << EOF >> ${SOURCE}
        fpga@${IMAGE_COUNTER} {
            description = "FPGA";
            data = /incbin/("${IMAGE_FPGA}");
            type = "fpga";
            arch = "${UBOOT_ARCH}";
            compression = "none";
            hash@1 {
                algo = "${VERIFIED_BOOT_HASH_ALGORITHM}";
            };
        };
EOF
}

#
# Emit the fitImage ITS firmware configuration section
#
# $1 - FIT source
# $2 - Firmware ID
fitimage_emit_section_firmware_config() {
    SOURCE=$1
    conf_csum="sha1"
    conf_desc="Boot U-Boot"

    cat << EOF >> ${SOURCE}
        default = "conf@1";
        conf@1 {
            description = "${conf_desc}";
            kernel = "kernel@$2";
            ramdisk = "ramdisk@$3";
            fdt = "fdt@$4";
            fpga = "fpga@$5";

/*            fpga = "fpga@1$5";
                signature@1 {
                algo = "${VERIFIED_BOOT_ALGORITHM}";
                key-name-hint = "${VERIFIED_BOOT_KEYNAME}";
            };
*/
        };
EOF
}

#
# Emit the fitImage ITS configuration section
#
# $1 - FIT source
# $2 - Linux kernel ID
# $3 - Ramdisk image ID
fitimage_emit_section_config() {
    SOURCE=$1

    # Test if we have any DTBs at all
    if [ -z "${3}" ] ; then
        conf_desc="Boot Linux kernel"
        ramdisk_line=""
    else
        conf_desc="Boot Linux kernel with ramdisk"
        ramdisk_line="ramdisk = \"ramdisk@${3}\";"
    fi
    kernel_line="kernel = \"kernel@${2}\";"

    cat << EOF >> ${SOURCE}
        default = "conf@1";
        conf@1 {
            description = "${conf_desc}";
            ${kernel_line}
            ${ramdisk_line}
            signature@1 {
                algo = "${VERIFIED_BOOT_ALGORITHM}";
                key-name-hint = "${VERIFIED_BOOT_KEYNAME}";
                sign-images = "kernel", "ramdisk";
            };
        };
EOF
}

defconfig_option_on() {
  OPTION=${1}
  SOURCE=${2}
  sed -i "s/^# ${OPTION}=/${OPTION}=/g" ${SOURCE}
  sed -i "s/^# ${OPTION} is not set/${OPTION}=y/g" ${SOURCE}
}

defconfig_option_off() {
  OPTION=${1}
  SOURCE=${2}
  sed -i "s/^${OPTION}=/# ${OPTION}=/g" ${SOURCE}
}
